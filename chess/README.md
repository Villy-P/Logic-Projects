# TS-Chess

Chess game in TypeScript. For Logic class

1187 lines of non-autogenerated code

2368 lines of code total (Without the .md file)

## Sources Used

---

[W3Schools](https://www.w3schools.com/) for HTML and CSS stuff.

[Wikipedia](https://www.wikipedia.org/) for computer stuff.

[Stack Overflow](https://stackoverflow.com/) for answers to stuff.

[SebLague](https://github.com/SebLague) for some FEN handling.

[Mozilla Web Docs](https://developer.mozilla.org/en-US/) for JS functions.

---

## Languages Used

---

- **TypeScript** for the majority of the code.
- **JavaScript** (TypeScript compiles into JavaScript, so about half of the code will be JavaScript)
- **SASS/CSS** For styling the webpage
- **HTML** for making the webpage
- **Git** for source control
- **JSON** for the tsconfig file

---

## HTML

---

HTML (Hyper Text Markup Language) is a language used for creating webpages.
All webpages on the internet has an HTML page.
HTML uses tags to create webpages.

Each page needs to start with a `DOCTYPE` tag like this:

``` html
<!DOCTYPE html>
```

This tells the browser to expect a HTML type when it loads in the page.

Next you can specify the language as such:

``` html
<html lang="en">
```

The `<html>` tag needs to have an ending. In fact, most tags in HTML need endings.
Here is an example of the *paragraph* tag, which tells the browser to load in text:

``` html
<p>This is a paragraph tag with an ending --></p>
```

The `<html>` tags ending will be located at the end of the file.
All code within these two tags will be loaded into the webpage.

Next we specify a `<head>` tag like so:

``` html
<head>
    <title>Chess</title>
    <link rel="stylesheet" href="src/CSS/style.css">
</head>
```

This tag is used for storing data about the webpage.
That `<title>` tag tells the browser what name to give the webpage so it can display it to the user.

We'll come back to what the `<link>` tag does later.

Right after the `<head>` tag we have our `<body>` tag, which tells the webpage what to display to the screen.

The first the in out `<body>` is `<ul>`, which specifies a new unordered list.
Within the `<ul>` tag we give it an `id` of `"header"`, so that in the CSS and TypeScript/JavaScript we can access it by that id.

Within the unordered list we have the `<li>` tag which is a list item.

Here is an example of the `<ul>` tag and the `<li>` tag.

``` html
<ul>
    <li>This</li>
    <li>Is</li>
    <li>An</li>
    <li>Unordered</li>
    <li>List</li>
</ul>
```

This returns:

- This
- Is
- An
- Unordered
- List

Within the `<li>`, there is a `<a>` tag with a `href` of `javascript:void(0)` and a class of `dropdown`.
The class is sort of the same as an id, and the `href` attribute specifies what the link's destination will be.  
When we set that value to `javascript:void(0)`, it basically says *do nothing*.

Then we have this long `<div>` tag:

``` html
<div class="dropdown-content">
    <a href="#"><input type="color" value="#FFFFFF" id="colorWell1"> White Square</a>
    <a href="#"><input type="color" value="#006400" id="colorWell2"> Black Square</a>
    <a href="#"><input type="color" value="#5f9ea0" id="colorWell3"> Canvas Background</a>
    <a href="#"><input type="color" value="#25383C" id="colorWell4"> Background Color</a>
    <a href="#"><input type="color" value="#38444d" id="colorWell5"> Header Color</a>
    <a href="#"><input type="color" value="#FFFFFF" id="colorWell6"> History Canvas Background</a>
</div>
```

The `<div>` tag itself specifies a certain section of the webpage and it has a class name of `dropdown-content`.
Each item within the `<div>` tag has an `<a>` tag with a href of `"#"` (do nothing) and an `<input>` tag that specifies the type of input.
We set the `type` attribute to `color` so the webpage knows we will be making a color selector.
Then we give the base color value as a certain color value, which is a very fancy way of specifying different color (Like an RGBA value).
The `#FFFFFF` color is white, specified by the 3 pairs of `FF`, which means full values of Red, Green, and White (255, 255, 255).
Next we assign each value an `id` so we can access it in the TypeScript/JavaScript.
The White Text is what we will actually be displaying to the user.

When you look at the unordered list in the webpage it does not look like a list, but rather a bar with dropdowns.
This is due to styling in CSS, which we will go over later.

Next, we create two canvases with the `<canvas>` tag.
A canvas is a box that we can draw things on, such as shapes and images.
The `historyCanvas` will be used for displaying the game history, and the `mainCanvas` will be used for the actual chess game.

Next we have many `<script>` tags with an `src` attribute.
Whatever we put into `src`, the program will read whatever file and load that in. The `<script>` tag is for JavaScript, so we load in many Javascript pages.
We'll go over all these files later.

---

## SASS & CSS

---

In our HTML file, within the `<head>` tag, we have a `<link>` tag with a `rel` of `stylesheet` and a `href` of `src/CSS/style.css`.
`rel` stands for *relationship* and is used to tell what *type* of link it will be.
Then we assign it a link that points to our stylesheet.

Now, within our `src/CSS` we have three files:

- `style.css`
- `style.css.map`
- `style.scss`

The first two were autogenerated by the third one. The third one is a `Sass` file, which compiles to CSS.
CSS (Cascading Style Sheets) is *the worst thing to ever be made by humans*, and is used to style `HTML` elements.
SASS is a way of making CSS less garbage.
You set attributes to values in three ways:

``` css
/* By tag*/
body {}
/* By Id*/
#idName {}
/* By class name*/
.className {}
```

You will put the style elements within the braces.

Let's look at the first element: `body`.

Since there is no `#` or `.`, we know that we will be changing the attributes of a tag.
This means whatever changes we make will apply to all `<body>` tags.

This is our `body` part in the `style.scss` file:

``` css
body {
    background-color: #25383C;
}
```

In `<body>` we only have one attribute: `background-color`, which sets the background color of the body to a color code of `#25383C`.

Next we have two canvas values, but let's only look at the first one.

``` css
#mainCanvas  {
    background-color: cadetblue;
    border: 1px solid black;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);               
}
```

We have a title of `#mainCanvas`, which means whichever tags in the `HTML` file have an id of `mainCanvas`, apply these attributes to them.
In this case we are setting the attributes of the main canvas where our chess game will run on.

The first tag (`background-color`) sets the background of the canvas to `cadetblue` (HTML can also read plain text as colors too).
Then we set the `border` attribute to `1px solid black`.
This sets the border of the canvas to be one pixel wide and have a bold, black look to it.
The four next attributes have to do with setting the canvas to be centered on the screen.
Lets look at each of them.

- `position: absolute`
  - This means that the canvas will be positioned to be relative to the body. The next two properties will determine that.
- `top: 50%`
  - This sets the position relative to the top to 50%. For example, if the screen was 1000px tall, then the canvas would be placed 500px away from the top.
- `left: 50%`
  - This sets the position relative to the left to 50%. For example, if the screen was 1000px wide, then the canvas would be placed 500px away from the left.
- The two properties above cause the canvas to shift to the middle of the screen, however the top left corner of the screen will be at the center, so we will need to place the center of the canvas to the center of the screen.
- `transform: translate(-50%, -50%)`
  - The `transform` property will move the canvas to the place provided.
  - The `translate` function will move it in whichever direction specified.
    - In this case, we translate it -50% in both directions because we want to shift if left and up by half of the canvas width and height. This causes the center of the canvas to be in the very center of the screen.

Next we have a bunch of properties for the navigation bar at the top of the screen. The rest of the code is used to make unordered lists look like that.

First we need to set the properties of the unordered list itself.

``` css
ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #38444d;
}
```

Lets go over these properties one by one.

- `list-style-type: none`
  - If we were to create an unordered list in HTML without any CSS it would look like a normal, bulleted list. What we do with this tag is remove the bullet points.
- `margin: 0` and `padding: 0`
  - We'll go over these later.
- `overflow: hidden`
  - This says that if any of the value overflow (cannot be fit on the screen) to hide them from the user.
- `background-color`
  - Sets the background color

Now for `margin: 0` and `padding: 0`.

To understand these, first we have to understand the **box model**.

This is a box model:

``` text
╔═══════════════════════════╗
║           Margin          ║
║  ╔═════════════════════╗  ║
║  ║        Border       ║  ║
║  ║  ╔═══════════════╗  ║  ║
║  ║  ║    Padding    ║  ║  ║
║  ║  ║  ╔═════════╗  ║  ║  ║
║  ║  ║  ║ Content ║  ║  ║  ║
║  ║  ║  ╚═════════╝  ║  ║  ║
║  ║  ╚═══════════════╝  ║  ║
║  ╚═════════════════════╝  ║
╚═══════════════════════════╝
```

These are the parts of a box model:

- Margin
  - A transparent area around the border.
- Border
  - A border that surrounds the padding.
- Padding
  - A transparent area around the content.
- Content
  - The actual content (In this case an unordered list)

When we set the `margin` and `padding` to `0`, we are saying that there is no margin or padding.

Next we have `li`.

``` css
li {
  float: left;    
}
```

`li` is a list element, so out unordered list contains `li` tags.
The `float` property tells all `li` tags to float to the left of the list, so in our navigation bar it will look like this:

``` text
╔═══════╦═══════════════════╗
║ Item  ║ Item              ║
╚═══════╩═══════════════════╝
```

If `float` were right, our navigation bar would look like this:

``` text
╔════════════════════╦══════╗
║               Item ║ Item ║
╚════════════════════╩══════╝
```

After this we have this block of code:

``` css
li a, .dropbtn {
  display: inline-block;
  color: black;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}
```

The `li a` tells the HTML that we are looking for `<a>` tags within `<li>` tags.
The `.dropbtn` says we are also looking for a tag with the class name of `dropbtn`.

Lets go over all these attributes:

- `display: inline-block`
  - Set the display type to an inline block element.
- `color: black`
  - Unlike `background-color`, `color` sets the color of the text, so any text displayed on an `a` tag within a `li` tag with a class name of `dropbtn` will be `black`.
- `text-align: center`
  - Centers any text at the middle of that element.
- `padding: 14px 16px`
  - This sets the top and bottom padding to 14px and the left and right padding to 16px.
- `text-decoration: none`
  - Tells the HTML that the text should have no decoration applied to it.

Next we have another block:

``` css
li a:hover, .dropdown:hover .dropbtn {
  background-color: red;
}
```

This says whenever we hover over an `a` tag within a `li` tag with a class name of `dropbtn` within an element that has a class name of `dropdown`, change the background color to `red`.

Here are some more blocks (With their explanations in green)

``` css
/* Find a <li> tag with a class of dropdown */
li.dropdown {
  display: inline-block;
}

/* When you hover over a dropdown-content class and an <a> tag, change the background color to gray */
.dropdown-content a:hover {
  background-color: gray;
}

/* When you hover over a dropdown class and with a class of dropdown-content */
.dropdown:hover .dropdown-content {
  display: block;
}
```

Now we have another block:

``` css
.dropdown-content {
  display: none;
  position: absolute;
  background-color: black;
  min-width: 160px;
  z-index: 1;
}
```

- `display: none`
  - Hides the display (While you are not hovering over it)
- `position: absolute`
  - This means that the canvas will be positioned to be relative to the body.
- `background-color: black`
  - Sets the background color to black.
- `min-width: 160px`
  - The width of the element will never be less than 160px.
- `z-index: 1`
  - Sets the z-order of the element (So this element will be on top of all others)

Most of the other elements have attributes that we have seen before, so we don't need to view other elements.
Now SASS, CSS, and HTML are *not* exactly programming languages.
You could call them programming languages because they all provide instructions to the computer, but none of them are turing complete.
In order to be turing complete it needs to be able to run programs efficiently. HTML doesn't have if statements and SASS/CSS don't have functions so they can't do recursion.
In order to have a turing complete language in the trio, we need *JavaScript*, but before we dive into that mess, we need to talk about other programs that this project uses.

---

## Git

---

[Git](https://git-scm.com/) is a version control software designed to track changes within files.
Git is often used with [Github](https://github.com/) to make version control even easier.
This project uses Git and Github to help track when changes were made and revert changes.

### Using Git for projects on Windows

> *You can skip this part if you are not interested in Git*

Visit [this](https://git-scm.com/downloads) website and install Git.
Next, follow all the instructions in the installer.
Once you are finished you need to add GIT to your path. Click on the windows button on your keyboard and type in "PATH".
After that click on the "Edit the system environment variables."
Then click the button that says "Environment variables."
After that click on the path in the top box and click the button below that which reads "Edit."
Then you will see a list of all programs on your PATH.
Then click a blank rectangle and click "Edit."
After that enter the path in which Git is installed (Usually C:/Programs/Git).
The reason we put Git on our path is so we an use the `git` command in the command line.

Press Windows Key + R on your keyboard to open "Run." Then type in `cmd`.
You are now in your command line.

> Another option is to use Windows Powershell, which comes installed on your computer.

Whenever you open the command line it should look like this:

``` text
Microsoft Windows [Version version_here]
(c) copyright_year Microsoft Corporation. All rights reserved.

C:\Users\your_user_name_here>
```

From here type in `git` and this should pop up:

``` text
usage: git [-v | --version] [-h | --help] [-C <path>] [-c <name>=<value>]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           [--super-prefix=<path>] [--config-env=<name>=<envvar>]
           <command> [<args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone     Clone a repository into a new directory
   init      Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add       Add file contents to the index
   mv        Move or rename a file, a directory, or a symlink
   restore   Restore working tree files
   rm        Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect    Use binary search to find the commit that introduced a bug
   diff      Show changes between commits, commit and working tree, etc
   grep      Print lines matching a pattern
   log       Show commit logs
   show      Show various types of objects
   status    Show the working tree status

grow, mark and tweak your common history
   branch    List, create, or delete branches
   commit    Record changes to the repository
   merge     Join two or more development histories together
   rebase    Reapply commits on top of another base tip
   reset     Reset current HEAD to the specified state
   switch    Switch branches
   tag       Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch     Download objects and refs from another repository
   pull      Fetch from and integrate with another repository or a local branch
   push      Update remote refs along with associated objects

'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help <command>' or 'git help <concept>'
to read about a specific subcommand or concept.
See 'git help git' for an overview of the system.
```

All of these are thing you can do in git.

To set up Git for you, type in these commands:

``` text
> git config --global user.name "John Doe"
> git config --global user.email "email@provider.com"
```

This configures Git for you specifically.

In order to make Git easier go to [Github](https://github.com/) and sign up.
Then click on the plus sign in the top right and create a new repository.
From there, give it a name and make it private.
You can also add a README file.
Then hit create.
This is your new repository.

You can `clone` this repository by running `git clone` from the command line and then a link to your project.

Then when you finish what you are doing you can `git commit` to commit those changes.
Be sure to always give your commits descriptive names.
Then you can `git push` to push those changes to Github.

Now we can finally get into TypeScript and JavaScript.

---

## JavaScript

---

In order to understand TypeScript we first need to understand JavaScript.
JavaScript is a programming language used to make webpages with CSS and HTML.

Here is some example JavaScript.

``` javascript
function binarySearch(array, target) {
  let left = 0;
  let right = array.length - 1;
  while (left <= right) {
    let middle = Math.floor((left + right) / 2);
    if (array[middle] == target)
      return middle;
    else if (array[middle] < target>)
      left = middle + 1;
    else
      right = middle - 1;
  }
  throw `Target ${target} was not found in array!`;
}
```

Now JavaScript is dynamically typed, which means that it infers the types of variables and allows variables to change types.
Here is an example of that:

``` javascript
let variable = "variable"; // Variable is an string.
variable = 0;              // Variable is a number.
variable = false;          // Variable is a boolean.
console.log(variable);     // Prints false.
```

In statically typed languages such as C++, C, C#, and Java, variables need type names.
Here is the same code but in C++.

``` cpp
#include <string>
#include <iostream>

using namespace std; // Import STANDARD library

int main(void) {
  // Create a variable with type string and assigns the value "variable" to it
  string variable = "variable";
  // This throws an error because type "int" is not assignable to std::string
  variable = 0;
  // The program will stop due to the error so none of the code below will run
  variable = false;
  cout << variable << endl;
  return 0;
}
```

One may think that having a dynamically typed language is worse, however take this code:

``` javascript
class Point {
  constructor(x) {
    this.x = x;
  }
}

let point = new Point(100);
console.log(point.x);
console.log(point.y);
```

The first `console.log` will log `100` but the second one `undefined` because point.y does not exist.
This is unexpected behavior and defiantly something we don't want.
This is that same code in C++:

``` cpp
// main.h

#ifndef MAIN_H
#define MAIN_H

class Point {
  public:
    int x;

    Point(int x);
}

#endif

// main.cpp

#include "main.h"

#include <iostream>

using namespace std;

Point::Point(int x) {
  this->x = x;
}

int main(void {
  Point point(100);
  cout << point.x << endl;
  cout << point.y << endl; // Point doesn't have a y value!
}
```

It will give you the warning before you run the code because it knows that the point class has no attribute y.
This is one of the reasons that Javascript is bad. Another reason is how weird it is.

Here are some examples (You can try them yourself by pressing ctrl + shift + i within Google Chrome and clicking on Console):

| Code                | Explanation                      | What it returns     |
|---------------------|----------------------------------|---------------------|
| `typeof NaN`        | What is the type of not a number | `number`            |
| `Math.max()`        | Maximum number                   | `-Infinity`         |
| `Math.min()`        | Minimum number                   | `Infinity`          |
| `0.1 + 0.2 === 0.3` | Does 0.1 + 0.2 equal 0.3?        | `false`             |
| `[] + {}`           | Empty array plus empty object    | `"[object Object]"` |
| `{} + []`           | Empty object plus empty array    | `0`                 |
| `false + []`        | False plus empty array           | `false`             |
| `++[[]][+[]]`       | A mess                           | `1`                 |

And there are *many* more examples of this.
To counter this, we can use TypeScript.

---

## TypeScript

---

TypeScript is a statically typed, superset of JavaScript.
It adds types to JavaScript and access modifiers for class variables and functions.
It also adds all these things:

- Generics
- Namespaces
- Interfaces
- Union Types

Here is how the code above would work in TypeScript:

``` javascript
let variable: string = "variable"; // Variable is an string.
variable = 0; // Error: Type number cannot be assigned to 
variable = false;
console.log(variable);
```

To fix this, we can do two things.

``` javascript
// Option 1: Give variable type any
let variable: any = "variable"; // Variable is an string.
variable = 0; // Variable is a number
variable = false; // Variable is a boolean
console.log(variable); // Prints false

// Option 2: Use Union Types

// variable has three types that can be assigned to it 
let variable: string | number | boolean = "variable"; // Variable is an string.
variable = 0; // Variable is a number
variable = false; // Variable is a boolean
console.log(variable); // Prints false
```

In order to use TypeScript in HTML, we need to compile it first.
To do this, we run the `tsc` command in the command line (We'll go over this later) so the TypeScript will be compiled to JavaScript.
We can then use the JavaScript files in the html like this:

``` html
<script src="src/Style/colorInput.js"></script>
<script src="src/Style/history.js"></script>
<script src="src/Style/historyComponent.js"></script>
<script src="src/main.js"></script>
<script src="src/Board Utilities/fenHandling.js"></script>
<script src="src/Functions/functions.js"></script>
<script src="src/Board Utilities/board.js"></script>
<script src="src/Pieces/piece.js"></script>
<script src="src/Events/keyEvents.js"></script>
<script src="src/Pieces/black.js"></script>
<script src="src/Move Validation/move.js"></script>
<script src="src/Move Validation/check.js"></script>
<script src="src/Settings/userSettings.js"></script>
<script src="src/Settings/devSettings.js"></script>
<script src="src/init.js"></script>
```

When the TypeScript compiles it call the `tsconfig.json` file.
This is a "settings" file for the TypeScript compiler, so you can tell it what to do.
For example we can change the target JavaScript version using `"target"`.

### Starting With TypeScript

---

> Skip this part if you are uninterested

Step 1: Install [Node JS](https://nodejs.org/en/)

Step 2: Run `npm install -g typescript` to install TypeScript.

Step 3: Run `tsc init` to generate a `tsconfig.json` file.

Step 4: Run `tsc` or `tsc filename.ts` to compile TypeScript to JavaScript.

---

## Going through the files

---

### The Main.ts file

Here is our `main.ts` file:

``` typescript
class World {
  public static readonly canvas : HTMLCanvasElement        = <HTMLCanvasElement> document.getElementById("mainCanvas");
  public static readonly context: CanvasRenderingContext2D = World.canvas.getContext("2d")!;
  public static readonly boundingClient: DOMRect = World.canvas.getBoundingClientRect();
  public static readonly offsetX: number = World.boundingClient.left;
  public static readonly offsetY: number = World.boundingClient.top;
  public static readonly colorPickers: ColorInput = new ColorInput();
  public static readonly history: HistoryCanvas = new HistoryCanvas();
  public static drawCounter: number = 0;
  public static dragging: boolean = false;
  public static isWhiteTurn: boolean = true;

  public readonly board: Board = new Board();

  public constructor() {
    World.canvas.width  = (DevSettings.boxDimensions * 8) + DevSettings.numberLetterDimensions;
    World.canvas.height = (DevSettings.boxDimensions * 8) + DevSettings.numberLetterDimensions;
    World.canvas.onmousedown = KeyEvents.mouseDown;
    World.canvas.onmouseup = KeyEvents.mouseUp;
    World.canvas.onmousemove = KeyEvents.mouseMove;
  }
}
```

The first thing we do in our `main.ts` file is create a new `class` called `World`.

A `class` is a sort of `blueprint` for an object.
In a class, you can have member `variables` and member `functions`.
Each member item has an `access modifier` that specifies what other classes can do.
Here are all `access modifiers`:

- `public`
  - The object can be used anywhere.
- `private`
  - The object can only be used within the class it is in.
- `protected`
  - The object can only be used by the class it is in and any classes that inherit from it.

The very first variable of the `World` class is called `canvas`.
We give it a `public` access modifier.
We also use the `readonly` keyword.
The `readonly` keyword makes it so that the variable cannot be changed, and if you try to change it, the program will throw an error.

We also set the `canvas` to `static`.
This means that any class can access that variable.
For example: if we were in `Move.ts` and needed the canvas, we could call `World.canvas`.
This looks into the `World` class and finds the variable named `canvas`.

After this we give our canvas a type of `HTMLCanvasElement`.
After the equals sign we *cast* a value.
Casting is telling the TypeScript compiler that *I know what I'm doing and i know that this value is of this type.*
We set the value of `World.canvas` to `document.getElementById("mainCanvas")`. Here is what that does:

- `document` calls the HTML body.
- Within the `document`, we get an element by it's ID.
- We get the ID of `mainCanvas`.
- Then, we tell the compiler that we know that we just got an `HTMLCanvasElement`, so it sets the type to that.

Next, we create the `context` of the `canvas`.
The `context` will be used to draw shapes and text to the canvas.
Whenever we call `getContext` on a canvas, it has a chance to return `null`, which is the German word for zero, because it does not know that the canvas has a context.
We can put a `!` after the value to tell the compiler that *I, the developer have specifically checked this variable and have confirmed that it does not equal null*.

Next we get the bounding rectangle of the canvas by calling `World.canvas.getBoundingClientRect()`.
This gets the position of the canvas relative to the body.
We use this later to get info about where the user clicked their mouse.

Since we only need two values from the bounding rectangle, we can give the values to variables called `xOffset` and `yOffset`.

Next we have two variables that create new classes, however we will go over these when we get to their respective files.

After those two, we have a `drawCounter` set to 0. Later, we will check if that value has hit 100 to end the game due to a draw.

Next, we have a variable that is a `boolean` (`true` or `false`) that checks if we are currently dragging a piece.
We also have another `boolean` to check if it is white's turn.

Then we initialize the board, which we will go over when we reach he `board.ts` file.

Next we have our `constructor`.
A `constructor` is called whenever a class is created.
For example, we have this program (in C#)::

``` csharp
public class Item {
  // In most languages, constructors are made by using the class name as a function. Javascript used the constructor keyword.
  public Item() {
    Console.WriteLine("Constructor Called");
  }
}

public class Program {
  // Program.Main will be called when the Program is run.
  public static void Main(string[] args) {
    Console.WriteLine("Program Started");
    Item item = new Item();
    Console.WriteLine("Program Ended");
  }
}
```

If we run this program, this is the output:

``` text
Program Started
Constructor Called
Program Ended
```

This is because the `Console.WriteLine("Constructor Called")` was within the constructor, which was called when the variable `item` is initialized.
It's the same deal in TypeScript.
Within the constructor, we usually initialize class variables, but since `World` has no class variables, we don't.
Instead, we set some properties of the `World` variables.

The first thing we do is set the width and height of our canvas.
We do this by calling two static variables from another class, `DevSettings`.
We won't go over the `DevSettings` class, but all you need to know is it is settings that the developer (me) can set for debugging and playtesting.
We calculate the width and height, and then we set some more properties.
We'll go over the values later, but what this does is it maps functions to events.
So when the mouse goes down, it calls `KeyEvents.mouseDown()` (We don't need the parenthesis).

Now that we have finished the `main.ts` file, we should go into some of the UI files before getting into the actual chess game.

### The ColorInput.ts file

Here is our `colorInput.ts` file:

``` typescript
class ColorInput {
  public static colorWell1: any = document.getElementById("colorWell1")!;
  public static colorWell2: any = document.getElementById("colorWell2")!;
  public static colorWell3: any = document.getElementById("colorWell3")!;
  public static colorWell4: any = document.getElementById("colorWell4")!;
  public static colorWell5: any = document.getElementById("colorWell5")!;
  public static colorWell6: any = document.getElementById("colorWell6")!;

  public constructor() {
    ColorInput.colorWell1.addEventListener("change", this.watchColorPickerOnePicker);
    ColorInput.colorWell2.addEventListener("change", this.watchColorPickerTwoPicker);
    ColorInput.colorWell3.addEventListener("change", this.watchColorPickerThreePicker);
    ColorInput.colorWell4.addEventListener("change", this.watchColorPickerFourPicker);
    ColorInput.colorWell5.addEventListener("change", this.watchColorPickerFivePicker);
    ColorInput.colorWell6.addEventListener("change", this.watchColorPickerSixPicker);
  }

  public watchColorPickerOnePicker(event: any) {
      ColorInput.colorWell1.style.color = event.target.value;
      UserSettings.whiteSquareColor = event.target.value;
  }

  public watchColorPickerTwoPicker(event: any) {
      ColorInput.colorWell1.style.color = event.target.value;
      UserSettings.blackSquareColor = event.target.value;
  }

  public watchColorPickerThreePicker(event: any) {
      ColorInput.colorWell3.style.color = event.target.value;
      World.canvas.style.backgroundColor = event.target.value;
  }

  public watchColorPickerFourPicker(event: any) {
      ColorInput.colorWell4.style.color = event.target.value;
      document.body.style.backgroundColor = event.target.value;
  }

  public watchColorPickerFivePicker(event: any) {
      ColorInput.colorWell5.style.color = event.target.value;
      document.getElementById("header")!.style.backgroundColor = event.target.value;
  }

  public watchColorPickerSixPicker(event: any) {
      ColorInput.colorWell6.style.color = event.target.value;
      World.history.canvas.style.backgroundColor = event.target.value; 
  }
}
```

OK, so first thing we do is create a class with a name of `ColorInput`.
The we create six color wells by calling their ID's from the HTML.
These color wells are what you see when you hover over the `Colors` icon in the top navigation bar.
This file will be used to facilitate everything with those color wells.

Next, we have our constructors.
For each of our color wells, we add an event listener too them.
addEventListener has two arguments, and here they are:

- `type`
  - The type of input we are looking for. For the color wells, we are looking for changes in the color.
- `listener`
  - What to call when the item changes. This does not need to have parenthesis even though we are calling a function. This is because the function will only have one argument, the event, which JavaScript automatically assigns it.

So now we will check for changes in the color wells and if we find one we call the `listener`.

After this we have six functions, one for each well.
Each function has one argument, `event`, which can be anything.
I won't go through each one, but what you need to know is that it first updates the color picker value, then updates whatever color it is actually used for.

### The History file and the HistoryComponent file

Here is the `history.ts` file:

``` typescript
class HistoryCanvas {
  public readonly canvas: HTMLCanvasElement = <HTMLCanvasElement> document.getElementById("historyCanvas");
  public readonly context: CanvasRenderingContext2D = this.canvas.getContext("2d")!;

  public components: HistoryComponent[] = [];

  public constructor() {
    this.canvas.width = 200;
    this.canvas.height = 0;
  }

  public addComponent(component: HistoryComponent): void {
    this.canvas.height += 20;
    this.components.push(component);
  }

  public print(): void {
    Functions.drawLine(20, 0, 20, this.canvas.height, undefined, this.context);
    Functions.drawLine(110, 0, 110, this.canvas.height, undefined, this.context);
    for (let i = 1; i <= this.components.length; i++) {
      Functions.drawText(i + ":", 2, ((i) * 20 - 5), "black", "Arial", 10, undefined, undefined, this.context);
      Functions.drawText(this.components[i - 1].move1, 22, ((i) * 20 - 5), "black", "Arial", 10, undefined, undefined, this.context);
      Functions.drawLine(0, (i * 20), this.canvas.width, (i * 20), undefined, this.context);
    }
  }
}
```

And here is our `historyComponent.ts` file:

``` typescript
class HistoryComponent {
  public move1: string;
  public move2: string;

  public constructor(move1: string, move2: string) {
    this.move1 = move1;
    this.move2 = move2;
  }
}
```

Let's go over the `historyComponent.ts` file first, as it is much further.

The first thing we do in our `HistoryComponent` class is create two public variables, `move1`, and `move2` (Which goes unused, but YOU can do it!).

Then we create our constructor and have two arguments that match our variable names, and then within the constructor, we set our class variables to the parameters.

Here is how this works:

``` typescript
// Create a new HistoryComponent and pass in move1 and move2, which must be strings
let historyComponent: HistoryComponent = new HistoryComponent("move1", "move2");
// In the constructor, we set the values of the class too what we passed in.
// When we are outside of the class instead of using 'this' we use the class name instead.
// This prints out "move1" because when we initialized the history component we set move1 to "move1"
console.log(historyComponent.move1);
```

Now to our `history.ts` file.
First thing we do is grab our `historyCanvas` and set the `context` (Just like me did in `main.ts`).
Next we create a class variable called components, which will be an array of `HistoryComponent`'s.
This is how arrays work:

``` typescript
// Create a new variable called array and set its value to an empty array.
// The type is string[], which means that it must be an array with only string types.
let array: string[] = [];
// We can also let an array contain string or ints by doing this:
let array2: (int|string)[] = [];
// Now array is just an empty array:
// []
// We can add items to it:
array.push("String1");
// Now array is this:
// ["String1"]
// We can also add many values:
for (let i = 2; i < 10; i++)
  array.push("String" + i.toString());
// Now out array is this:
// ["String1", "String2", "String3", "String4", "String5", "String6", "String7", "String8", "String9"]
// We can also remove items:
array.pop();
// Now our array is this:
// ["String1", "String2", "String3", "String4", "String5", "String6", "String7", "String8"]
// We can call values by their index.
// In TypeScript and JavaScript, arrays start at index 0.
// Here is a visualization:

// ["banana", "squash", "carrot"]
//     ^          ^          ^
//   Index 0     Index 1    Index 2

// This returns "String5"
array[4];
```

We now make a constructor that just initializes the `height` and `width` properties of our `canvas`.
After that we make a function that adds a component to the list.
It starts by adding 20 to the `canvas` height.
Then it pushes the provided `HistoryComponent` to the `components` list.

Then we have a function that prints the history components to the history canvas.
You can notice that after the parenthesis and before the curly brace, there is a `: void`.
The specifies what the function will return.
`void` means that the function will return nothing.

The first thing we do in our `print()` function is call a method within the `Functions` class that draws a line.
I won't be going over the `functions.ts` file but I will explain the methods when we see them.
This is `Functions.drawLine` method:

``` typescript
// I spaced out the parameters so they will be more clear.
public static drawLine(
    x1: number, 
    y1: number, 
    x2: number, 
    y2: number, 
    width: number = .5, 
    context: CanvasRenderingContext2D
): void {
    context.beginPath();
    context.lineWidth = width;
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.stroke();
}
```

Our parameter names speak for themselves, so I won't go over them.
One parameter, `width` has a value preset, so if we don't pass in a width (or pass in `undefined`), then it will default to .5.

The `context.beginPath()` function starts the process of drawing a line.
Then, `context.lineWidth()` will be used to set the thickness of the line.
After that, we move the "cursor" to `x1, x2` with the `moveTo()` function.
Then we move the cursor to `y1, y2` with the `lineTo()` function.
`lineTo()` will also draw a line from wherever the cursor was to where is will be.
`stroke` finally displays the line.

Back to our `print()` method, we draw two lines splitting the canvas into three parts:

1. The number
2. White's move
3. Black's move (unimplemented)

Next we have a `for` loop. Here is an example of `for` loops:

``` typescript
// Create a new value called i
// Then do everything within the braces
// Add 1 (i++) to i
// If i is less than 5 then stop.
for (let i = 0; i < 5; i++) {
    console.log(i);
}
// The final result will be this:

// 0
// 1
// 2
// 3
// 4
```

So, in our `for` loop, we do things as long as `i` is less than the length of `this.components`.
Now, for each `component`, we can draw the number and what white played.
We also call `Functions.drawText()`.
Here it is:

``` typescript
public static drawText(
    text: string, 
    x: number, 
    y: number, 
    color: string = "black", 
    font: string = "Arial", 
    fontSize: number = 10, 
    textBaseline: string = "left", 
    textAlign: string = "left", 
    context: CanvasRenderingContext2D
) {
    context.fillStyle = color;
    context.font = `${fontSize}px ${font}`;
    context.textBaseline = <CanvasTextBaseline> textBaseline; 
    context.textAlign = <CanvasTextAlign> textAlign; 
    
    context.fillText(text, x, y);
}
```

Now here, most parameters are self explanatory, however there is `textBaseline` and `textAlign`.

- `textBaseline`
  - This controls where the text is positioned vertically. If we set this top `top` it will draw the text below the `x` value.
- `textAlign`
  - Same as `textBaseline` but horizontally.

First we set the `fillStyle` attribute of the context.
This sets the color of the text to whatever we provided.
Then we set the font using a format string.
A format string uses \`backticks\`.
Whenever we use `${}` in a format string, we can use variables within the braces.
Then we set the `textBaseline` and `textAlign` attributes.

After that, we draw the text using `fillText`.

We will call `print()` later.
For now let us move on to the actual chess.

### The FenHandling file

Here is the `fenHandling.ts` file:

``` typescript
class FenHandling {
    public static readonly startWhiteFenString: string = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

    public static fillBoardFromFEN(fen: string): void {
        Board.pieces = [];
        Board.createEmptyBoard();
        const FENSTRING = fen.split(' ');
        let file: number = 0;
        let rank: number = 0;
        for (const char of FENSTRING[0].split("")) {
            if (char === '/') {
                file = 0;
                rank++;
            } else {
                if (!Number.isNaN(Number(char))) {
                    file += parseInt(char);
                } else {
                    Board.pieces[rank][file] = new Piece(Piece.pieceIdentifiers.get(char)!, file, rank);
                    file++;
                }
            }
        }
    }

    public static loadFENFromPosition(board: Piece[][]): string {
        let fen: string = "";
        for (const array of board) {
            let emptySquares: number = 0;
            for (const piece of array) {
                if (piece.value === 0) {
                    emptySquares++;
                } else {
                    if (emptySquares != 0) {
                        fen += emptySquares;
                        emptySquares = 0;
                    }
                    if (piece.value != 0)
                        fen += piece.value.toString();
                }
            }
            if (emptySquares != 0)
                fen += emptySquares;
            fen += '/';
        }
        fen = fen.slice(0, -1);

        fen += " w KQkq - 0 1"
        return fen;
    }
}
```

Now that first variable may seem very confusing to you.
That is what is called a FEN String.
FEN stands for Forsyth–Edwards Notation, named after Scottish newspaper David Forsyth.
Here are the parts of a FEN String and a table to accompany them:

- Placement data
  - Calculate the position of the pieces on a square. Take this FEN string: `1n1rk3/pR6/8/B2p1p2/4n3/2N2b2/PP5P/2KR4`
    - First we move one square, then place a black knight, then move one square, place a black rook and then a black king, then skip three squares and go down a rank. After that place a black pawn, the a white rook, then skip six squares and go down a rank. Then skip eight squares and go down a rank, then place a white bishop, skip two squares, place a black pawn, skip a square, and then place a black pawn, then skip two squares and go down a rank. Then Skip four squares and place a black knight then skip three squares and go down a rank. Then skip two squares and place a white knight then skip teo squares then add a black bishop then skip two squares and go down a rank. After that place two white pawns and skip five squares and place a white pawn then go down a rank. Finally, skip two squares, place a white king, a white rook, then skip 4 squares.
- Player to move
  - `w` for white, `b` for black.
- Castling
  - If neither side can castle, this is `-`.
  - If white can castle kingside, a `K` is added.
  - If white can castle queenside, a `Q` is added.
  - If black can castle kingside, a `k` is added.
  - If black can castle queenside, a `q` is added.
- En passant target square
  - If the previous move was not a pawn or a pawn not moving two squares, this is `-`.
  - If it was, than this will be the square that the pawn moved over (If the king pawn moved to e4 than this will be e3).
- 50 move rule clock
  - A number indicated by the number of moves since a capture or pawn movement. This is for the 50 move draw rule.
- Full move counter
  - A number indicated by the number of moves played. Incremented by 1 after black has moved.

| Character  | Description                                                      |
|------------|------------------------------------------------------------------|
| Any number | Skip that many squares                                           |
| PRNBQK     | White piece of that type (N = Knight, K = King, Q = Queen, etc.) |
| prnbqk     | Black piece of that type (n = Knight, k = King, q = Queen, etc.) |
| /          | Go down one rank                                                 |

The first variable is the FEN for the starting position from white's side.

The first function is used to load a position from a FEN string.
First we create a new board then fill it with blank objects (This will come up later).
After that we use the `split()` function to split the string by spaces.
Then we specify the file and rank.
After that we loop through each character of the FEN string.
First we check to see if it is a slash.
If it is we reset the file and add one to the rank.
Otherwise we then check if the character is a number.
If it is then we add that number to the file.
Otherwise we set the piece at the position on the board and add one to the file.

If none of this makes sense now, it will once we get to `board.ts`.

Next we have a function that creates a FEN string based on a board.
The first thing we do is create an empty string.
Then we loop over all the arrays of the board.
We then create a variable that will store the amount of empty squares.
Then we loop over all the pieces in that array
If the pieces value is 0 then we add one to the empty squares.
Otherwise we check if there are no empty squares.
If that is `true`, then we add the number of empty squares to the FEN string and then set `emptySquares` to `0`.
The we check if the pieces value is not 0.
If that is `true`, then we add the value of that piece to the FEN string.
After that we check if the value of `emptySquares` is not equal to 0.
If it is not then we add the amount of empty squares to the FEN string.
After that we add a slash to the fen string.
Then after we exit both loops the we remove the last character of the FEN string with `slice` because there is an extra slash at the end of our string.
Then we add other data and return the FEN string.

### The Move file

This file is really big, so we are going to be looking at it function by function.

But first, we have variables that check if some pieces have moved for castling.

Here is the first function:

``` typescript
public static validWhitePawnMove(piece: Piece, newX: number, newY: number): boolean {
    if (newY !== 0 && newX !== 0) {
        if (piece.y - 1 == newY && piece.x - 1 == newX && Board.previousBoard[piece.y - 2][piece.x - 1].value != 0) {
            if (Board.previousBoard[piece.y - 2][piece.x - 1].value == -1) {
                if (Board.pieces[newY + 1][newX].value < 0)
                    Board.pieces[newY + 1][newX].value = 0;
                return true;
            }
        }
        if (piece.y - 1 == newY && piece.x + 1 == newX && Board.previousBoard[piece.y - 2][piece.x + 1].value != 0) {
            if (Board.previousBoard[piece.y - 2][piece.x + 1].value == -1) {
                if (Board.pieces[newY + 1][newX].value < 0)
                    Board.pieces[newY + 1][newX].value = 0;
                return true;
            }
        }
    }

    if (piece.y - 1 == newY && piece.x - 1 == newX && Board.pieces[piece.y - 1][piece.x - 1].value != 0)
        return true;
    if (piece.y - 1 == newY && piece.x + 1 == newX && Board.pieces[piece.y - 1][piece.x + 1].value != 0)
        return true;        

    if (piece.x !== newX) 
        return false;
    if (Board.pieces[piece.y - 1][piece.x].value != 0)
        return false;
    if (piece.y - 1 === newY)
        return true;
    if (piece.y - 2 == newY && newY == 4 && Board.pieces[piece.y - 2][piece.x].value === 0)
        return true;
    return false;
}
```

So that first if statement is for en passant.
In short, if the previous board had a pawn and that pawn moved two squares then we can capture that pawn.
After that we check if the pawn has captured normally by checking if the pieces `y` has been decreased by one and if the `x` has been decreased/increased by one and if there is a piece available to capture it that spot.
After that we know that the pawn must stay on its `x` so if it is not then we return `false`.
Then if the square in front of the pawn is occupied by another piece then we return `false`.
After that we check if the pawn is moving one square.
Then after that we check if the pawn has moved two squares and is moving from its original position, along with checking if a piece is occupied by another piece.

The piece validation for black pawns is the exact same, but reversed, so I won't be going to explain that.
We also have two functions that check if a pawn can capture, which just takes some code from our `validWhitePawnMove` function.

After that we have our valid rook movements:

``` typescript
public static validRookMove(piece: Piece, newX: number, newY: number) {
    if (piece.x !== newX && piece.y !== newY) 
        return false
    if (piece.y === newY) {
        if (piece.x < newX) {
            for (let i = piece.x + 1; i < newX; ++i) 
                if (Board.pieces[piece.y][i].value != 0)
                    return false;
        } else {
            for (let i = piece.x - 1; i > newX; i--)
                if (Board.pieces[piece.y][i].value != 0)
                    return false;
        }
    } else if (piece.x === newX) {
        if (piece.y < newY) {
            for (let i = piece.y + 1; i < newY; ++i)
                if (Board.pieces[i][piece.x].value != 0)
                    return false;
        } else {
            for (let i = piece.y - 1; i > newY; i--)
                if (Board.pieces[i][piece.x].value != 0)
                    return false
        }
    } else {
        return false;
    }
    if (piece.x == 0 && piece.y == 7)
        Move.whiteLeftRookMoved = true;
    if (piece.x == 7 && piece.y == 7)
        Move.whiteRightRookMoved = true;
    if (piece.x == 0 && piece.y == 0)
        Move.blackLeftRookMoved = true;
    if (piece.x == 0 && piece.y == 7)
        Move.blackRightRookMoved = true;
    return true;
}
```

So first we check if the rook's `y` and `x` is different then its `newX` and `newY`.
If so, the rook is trying to move diagonally, so we reject that move.
Then we have a block of code that, in short, goes in every direction and if there is a piece blocking the way, return `false`.
Then we check the rook's coordinates and assign variables to true if the rook has moved.
Then we return `true` because the rook has made a valid move.

Next we do knight moves:

``` typescript
public static validKnightMove(piece: Piece, newX: number, newY: number): boolean {
    if (piece.y - 2 === newY && (piece.x + 1 === newX || piece.x - 1 === newX))
        return true;
    if (piece.y + 2 === newY && (piece.x + 1 === newX || piece.x - 1 === newX))
        return true;
    if (piece.y - 1 === newY && (piece.x + 2 === newX || piece.x - 2 === newX))
        return true;
    if (piece.y + 1 === newY && (piece.x + 2 === newX || piece.x - 2 === newX))
        return true;
    return false;
}
```

A knight's move is very easy, as it can jump over pieces.
Here we just check if it has moved to one of the eight valid squares around it.
If so return `true`.
If all cases return `false`, then just return `false`.
You may be thinking that a knight can just move outside of the board because we have no check for that.
We will fix that problem for *all* pieces eventually.

Next is bishops:

``` typescript
public static validBishopMove(piece: Piece, newX: number, newY: number): boolean {
    // Down-Right
    if (newX > piece.x && newY > piece.y)
        for (let i = 1; i < Math.max(newX - piece.x, newY - piece.y); i++)
            if (!(piece.y + i < 0 || piece.y + i > 7 || piece.x + i < 0 || piece.x + i > 7))
                if (Board.pieces[piece.y + i][piece.x + i] != undefined)
                    if (Board.pieces[piece.y + i][piece.x + i].value != 0)
                        return false;
    // Up-Left
    if (newX < piece.x && newY < piece.y)
        for (let i = 1; i < Math.max(piece.x - newX, piece.y - newY); i++)
            if (!(piece.y - i < 0 || piece.y - i > 7 || piece.x - i < 0 || piece.x - i > 7))
                if (Board.pieces[piece.y - i][piece.x - i] != undefined)
                    if (Board.pieces[piece.y - i][piece.x - i].value != 0)
                        return false;
    // Down-Left
    if (newX < piece.x && newY > piece.y)
        for (let i = 1; i < Math.max(piece.x - newX, newY - piece.y); i++)
            if (!(piece.y + i < 0 || piece.y + i > 7 || piece.x - i < 0 || piece.x - i > 7))
                if (Board.pieces[piece.y + i][piece.x - i] != undefined)
                    if (Board.pieces[piece.y + i][piece.x - i].value != 0)
                        return false;
    // Up-Right
    if (newX > piece.x && newY < piece.y)
        for (let i = 1; i < Math.max(newX - piece.x, piece.y - newY); i++)
            if (!(piece.y - i < 0 || piece.y - i > 7 || piece.x + i < 0 || piece.x + i > 7))
                if (Board.pieces[piece.y - i][piece.x + i] != undefined)
                    if (Board.pieces[piece.y - i][piece.x + i].value != 0)
                        return false;
    return Math.abs(newX - piece.x) == Math.abs(newY - piece.y);
}
```

For each direction the bishop can move, we check if a square is being occupied.
If it is occupied, then return `false`.
If not, then we can check if the bishop moved diagonally by using the formula shown above.

Up next is the Queen:

``` typescript
public static validQueenMove(piece: Piece, newX: number, newY: number): boolean {
    if (Move.validBishopMove(piece, newX, newY) || Move.validRookMove(piece, newX, newY))
        return true;
    return false;
}
```

Now, this code is very short.
This is because we can check if the move is a valid rook move or bishop move due to the fact that a Queen is a combination of the rook and bishop's moves.

Next up is the King:

``` typescript
public static validWhiteKingMove(piece: Piece, newX: number, newY: number): boolean {
    if (
        newY === piece.y && 
        piece.x + 2 === newX && 
        !Move.whiteRightRookMoved && 
        !Move.whiteKingMoved && 
        Board.pieces[piece.y][piece.x + 1].value == 0 &&
        !Check.squareBeingAttackedByBlackPiece(piece.x, piece.y, Board.pieces) &&
        !Check.squareBeingAttackedByBlackPiece(piece.x + 1, piece.y, Board.pieces) &&
        !Check.squareBeingAttackedByBlackPiece(piece.x + 2, piece.y, Board.pieces)
    ) {
        Move.whiteKingMoved = true;
        Move.whiteRightRookMoved = true;
        Board.pieces[piece.y][piece.x + 1] = Board.pieces[piece.y][piece.x + 3];
        Board.pieces[piece.y][piece.x + 1].x = piece.x + 1;
        Board.pieces[piece.y][piece.x + 1].y = piece.y;
        Board.pieces[piece.y][piece.x + 3] = new Piece(0, piece.x + 3, piece.y);
        return true;
    }
    if (
        newY === piece.y &&
        piece.x - 2 === newX &&
        !Move.whiteLeftRookMoved &&
        !Move.whiteKingMoved &&
        Board.pieces[piece.y][piece.x - 1].value == 0 &&
        Board.pieces[piece.y][piece.x - 3].value == 0 &&
        !Check.squareBeingAttackedByBlackPiece(piece.x, piece.y, Board.pieces) &&
        !Check.squareBeingAttackedByBlackPiece(piece.x - 1, piece.y, Board.pieces) &&
        !Check.squareBeingAttackedByBlackPiece(piece.x - 2, piece.y, Board.pieces)
    ) {
        Move.whiteKingMoved = true;
        Move.whiteLeftRookMoved = true;
        Board.pieces[piece.y][piece.x - 1] = Board.pieces[piece.y][piece.x - 4];
        Board.pieces[piece.y][piece.x - 1].x = piece.x - 1;
        Board.pieces[piece.y][piece.x - 1].y = piece.y;
        Board.pieces[piece.y][piece.x - 4] = new Piece(0, piece.x - 4, piece.y);
        return true;
    }
    if (newX > piece.x + 1 || newX < piece.x - 1 || newY > piece.y + 1 || newY < piece.y - 1)
        return false;
    Move.whiteKingMoved = true;
    Move.whiteRightRookMoved = true;
    return true;
}
```

The whole complicated mess of two `if` statements is for castling.
This is how the works:

- Is the King moving two squares in one direction?
- Has the King or Rook not moved?
- Are there no pieces in the way?
- Are none of the squares being attacked by a black piece?
- If all of these are `true` then:
  - The white King has moved
  - The white Rook has moved
  - Move the King and Rook
  - Return true

If the king has not castled, then we just check if the king has moved more than one square.
If he has, return `false`, otherwise set the white king as having moved.
Then return `true`.

The black king code is the same, however inverted, so I won't go over it.

### The Piece file

The `piece.ts` file is also really large, so we'll split it up.

First things first, we declare some class variables:

``` typescript
public value: number;
public x: number;
public y: number;
public dx: number = 0;
public dy: number = 0;
public hasMoved: boolean = false;
public selected: boolean = false;
```

The value is determined like this:

| Piece           | Value                                       |
|-----------------|---------------------------------------------|
| White Pawn      | 1                                           |
| White Knight    | 2                                           |
| White Bishop    | 3                                           |
| White Rook      | 4                                           |
| White Queen     | 5                                           |
| White King      | 6                                           |
| Any black piece | Negative value of corresponding white piece |

`x` and `y` are essentially equivalent to `file` and `rank`.

`dx` and `dy` are used for drag and drop mechanics, which we will get into when we get to `board.ts`.
The `hasMoved` and `selected` variables are unused.

Next we have piece identifiers:

``` typescript
public static pieceIdentifiers: Map<string, number> = new Map([
    ['x', 0],
    ['p', -1],
    ['n', -2],
    ['b', -3],
    ['r', -4],
    ['q', -5],
    ['k', -6],
    ['P', 1],
    ['N', 2],
    ['B', 3],
    ['R', 4],
    ['Q', 5],
    ['K', 6]
]);

public static pieceNumberIdentifiers: Map<number, string> = new Map([
    [0, 'x'],
    [-1, 'p'],
    [-2, 'n'],
    [-3, 'b'],
    [-4, 'r'],
    [-5, 'q'],
    [-6, 'k'],
    [1, 'P'],
    [2, 'N'],
    [3, 'B'],
    [4, 'R'],
    [5, 'Q'],
    [6, 'K'],
]);
```

The first `hashmap` is used to convert FEN string piece identifiers to numbers, and the second `hashmap` is used to inverse that.

Now a `Map` (Also called `HashMap` or `Dictionary`) is a simple object:

`key`: `object`

So if you had this `HashMap`:

``` typescript
let map: Map<string, number> = new map([
    ["key", 10]
]);

console.log(map.get("key"));
```

This would print 10, because the value of `key` is 10.

Now, `Map`s may *look* simple, but they are extremely complicated.

Take this C code for example:

``` c
#include <stdio.h>

int main() {
    int a = 0;
    printf("%p\n", (void *)&a);

    return 0;
}
```

This code creates an `int` value assigned 0;

Now what do you think this prints?

It prints *the address of a*.
This is what it returned on my computer: `0x7ffcd9b18f94`

Your computer has memory, so whenever you create a new variable, it allocates a location in memory for that value.

Take this C code:

``` c
#include <stdio.h>

int main() {
    int a = 0;
    int b = 0;
    printf("%p\n", (void *)&a);
    printf("%p\n", (void *)&b);

    return 0;
}
```

Here we have another variable named `b`.

Now this is what it prints:

``` text
0x7fffac4debb0
0x7fffac4debb4
```

Now you can see the pointer value of `b` is 4 more than that of `a`.
This is because an int is 4 bytes, which is a term you may have heard before.

Now change `a` and `b` to `char` (character):

``` c
#include <stdio.h>

int main() {
    char a = 'b';
    char b = 'b';
    printf("%p\n", (void *)&a);
    printf("%p\n", (void *)&b);

    return 0;
}
```

This is what that prints:

``` text
0x7ffeb66d3c96
0x7ffeb66d3c97
```

A `char`'s size is 1 bit, so the memory is increased by 1.

This is better showed with an array:

``` c
#include <stdio.h>

int main() {
    int a[] = {1, 2, 3};
    for (int i = 0; i < 3; i++)
        printf("Address #%d: %p\n", i, (void *)&a[i]);
    return 0;
}
```

This is what this returns:

``` text
Address #0: 0x7ffcbc0f9c3c
Address #1: 0x7ffcbc0f9c40
Address #2: 0x7ffcbc0f9c44
```

When we initialize an array, it gets the length and allocates memory for the array.
As, you can see in the example above, each value goes up by 4 (ignore Address #0).

Now this becomes a problem when you get into dynamic arrays.
Dynamic arrays are arrays that can be modified after being initialized.

Such example's are:

``` text
Java: ArrayList<>
C#: List<>
C++: std::vector<>
Python: []
Ruby: {}
```

This is a problem because if you add a value to a dynamic array, there is a chance that the next item in memory is taken.
So now, during garbage collection (where the computer frees up memory), the array will have to relocated, which takes up precious time.

Now, for `HashMap`'s, JavaScript has to `hash` the variables.

When you create a new `key` it gets assigned to a value in memory and has a pointer to the `value` you gave it.
Now, `value`s may overlap, so in that case, it becomes a linked list.

C pointers are very complicated and the best way to learn more about them is to read up on hashing and pointers and to just work with c (or x86 assembly).

Back to our actual code, we have created two `HashMap`s.

Next we have our `constructor` which assigns values to our class variables.

Now we have this code:

``` typescript
public static getImageUrlFromFEN(fenUnit: number): string {
    let url: string = UserSettings.fileBeginning;
    switch (fenUnit) {
        case 1:  url += "WhitePawn";    break;
        case -1: url += "BlackPawn";    break;
        case 4:  url += "WhiteRook";    break;
        case -4: url += "BlackRook";    break;
        case 2:  url += "WhiteKnight";  break;
        case -2: url += "BlackKnight";  break;
        case 3:  url += "WhiteBishop";  break;
        case -3: url += "BlackBishop";  break;
        case 5:  url += "WhiteQueen";   break;
        case -5: url += "BlackQueen";   break;
        case 6:  url += "WhiteKing";    break;
        case -6: url += "BlackKing";    break;
    }
    return url + ".png";
}
```

This is used to get the image url in our files.
All you really need to know about is `switch`.

Here is an example of a switch statement:

``` typescript
let n: number = 1;

// Get the value of n
switch (n) {
    case 0:                     // If it is zero
        console.log("n is 0");  // log this
        break;                  // If this break is not here, then the code will break through.
    case 1:                    // If it is 1
        console.log("n is 1"); // log this
    case 2:
        console.log("n!");     // log this
}
```

So what this code will do is get the value of `n`.
`n` is not 0, so we skip that case.
`n` is 1, so we log "n is 1".
Since there is no `break`, we go through to the next case which is 2 and log "n!".

Anyways after that we have a promotion function:

``` typescript
public getPromotion(newY: number) {
    if (newY === 0 && this.value === 1) {
        let input: string | null =  prompt("Enter promotion value: (q)ueen, (r)ook, (k)night, (b)ishop (Default is Queen)");
        if (input === null)
            this.value = 5;
        else {
            let trueInput: string = input.toLowerCase();
            if (trueInput === 'r')
                this.value = 4;
            else if (trueInput === 'b')
                this.value = 3;
            else if (trueInput === 'k')
                this.value = 2;
            else
                this.value = 5;
        }
    }
}
```

This is for getting a promotion for a white pawn.

First we check if the piece is on the last square and is a white pawn.
Then we get the player's input using the `prompt()` function.
You can test the `prompt()` function by opening the Dev Tools window (Ctrl+Shift+I), going to `Console` and then typing in `prompt()`. You should see something like this:

``` text
╔═══════════════════════════╗
║  Site Name                ║
║                           ║
║  ╔════════════════════╗   ║
║  ║ |                  ║   ║
║  ╚════════════════════╝   ║
║                           ║
║             OK   Cancel   ║
╚═══════════════════════════╝
```

Now if the input is `null` (The user did not input anything), we can default to using the Queen.
Otherwise, we get the `trueInput` by using to `toLowerCase()` function on `input`.
This is so that if the user put `B` it would go to `b`.
Then we check what the user said and make the pawn change into whatever piece.
If the user put a random input (such as `sdkfjasjfdjhi`), we default to using the Queen.

After that, we check if the piece has a valid move:

``` ts
public static getValidMove(piece: Piece, newX: number, newY: number): boolean {
    switch (piece.value) {
        case 0:
            return false;
        case -1:
            return Move.validBlackPawnMove(piece, newX, newY);
        case 1:
            return Move.validWhitePawnMove(piece, newX, newY);
        case 2:
        case -2:
            return Move.validKnightMove(piece, newX, newY);
        case 3:
        case -3:
            return Move.validBishopMove(piece, newX, newY);
        case 4:
        case -4:
            return Move.validRookMove(piece, newX, newY);
        case 5:
        case -5:
            return Move.validQueenMove(piece, newX, newY);
        case 6:
            return Move.validWhiteKingMove(piece, newX, newY);
        case -6:
            return Move.validBlackKingMove(piece, newX, newY);
    }
    throw new Error("Pieces value is undefined");
}
```

Here we switch the pieces value and check if the piece's move is valid.
The `throw new Error` at the end is there because if the piece's value is not in the range of `-6` to `6` then we know something is wrong, so we throw an error.

After that we have a functions that inverts a number, but that is pretty self-explanatory.

Alright, then we have this block of code:

``` ts
public move(e: MouseEvent): void {
    this.selected = false;

    let newX: number = Math.floor(Functions.getMousePos(e).x / DevSettings.boxDimensions) - 1;
    let newY: number = Math.floor(Functions.getMousePos(e).y / DevSettings.boxDimensions) - 1; 
    this.dx = 0;
    this.dy = 0;  
    
    if (newX < 0 || newX >= 8 || newY < 0 || newY >= 8) 
        return;
    if (Board.pieces[newY][newX].value > 0)
        return;
    let check: boolean = Piece.getValidMove(this, newX, newY);
    if (check) {
        let historyComponent: string = "";
        let blackKing: Piece = Piece.getKing(false, Board.pieces);
        if (this.value === 6 && Board.pieces[newY][newX - 1].value === 4)
            historyComponent = "O-O";
        else if (Board.pieces[newY][newX].value === 0)
            historyComponent = Piece.pieceNumberIdentifiers.get(this.value) + "-" + String.fromCharCode(97 + newX) + Piece.invertNumber(newY);
        else
            historyComponent = Piece.pieceNumberIdentifiers.get(this.value)! + Piece.pieceNumberIdentifiers.get(Board.pieces[newY][newX].value) + 'x' + String.fromCharCode(97 + newX) + Piece.invertNumber(newY);
        if (this.value === 1)
            World.drawCounter = 0;
        if (Check.squareBeingAttackedByBlackPiece(newX, newY, Board.pieces) && this.value === 6)
            return;
        this.getPromotion(newY);
        Board.previousBoard = Functions.deepCopy(Board.pieces);
        this.hasMoved = true;
        Board.pieces[newY][newX] = this;
        Board.pieces[this.y][this.x] = new Piece(0, this.x, this.y);
        this.x = newX;
        this.y = newY;  
        if (Check.squareBeingAttackedByWhitePiece(blackKing.x, blackKing.y, Board.pieces))
            historyComponent += "+";
        if (Check.blackKingInCheckMate()) {
            alert("Black King is in checkmate. White has won the game!");
            return;
        }
        Black.makeMove();
        World.drawCounter += 2;
        if (World.drawCounter === 100) {
            alert ("Game has ended in a draw");
            return;
        }
        if (Check.whiteKingInCheckMate()) {
            alert("White King is in checkmate. Black has won the game!");
            return;
        }
        World.history.addComponent(new HistoryComponent(historyComponent, ""));
    }
}
```

First we de-select this piece.
Then we get the `newX` and `newY` properties by doing a complicated math formula.
This is what the `bounding rectangle` was for in the `World` class.
Next we set `dx` and `dy` to 0.
You'll understand those more when we get to the `keyEvents.ts` and `board.ts` file

Then, if the `newX` or `newY` values are off the board, then we `return`, as that would be an illegal move.
We also return if the piece at our destination is a white piece.

Then we check if our piece has made a valid move.
If it has, we initialize a history component.
This will hold the data about where our piece has moved so we can display it to the `historyCanvas`.
The next three `if`, `else if`, and `else` statements will create the string so we can make a `HistoryComponent` later.
Next, we check if the piece was a pawn.
If it was, we reset the draw counter.

After that, if the square we are moving to is in check and we moved a King, that is an illegal move as a King cannot move to a square that is in check.
Then we call our `getPromotion()` method from earlier.

Now we have confirmed that we have made a valid move.
So first we set the `hasMoved` property as `true`.
Then we set the the square we are moving to as the piece.
Then we set the square where we moved from as a blank piece.
After that we update the pieces `x` and `y`.

Then if we have put the black king in check, we add `+` to the history string.
After that, if black is in checkmate, we `alert` the user that that has happened.
Then black makes its move (we'll go over that later) add we add 2 to the draw counter.
If the draw counter is 100 then we alert the the game ended in a draw.
Then if the white king is in checkmate we alert that white has lost.
After all that we add a history component to the `historyCanvas`.

Now we have one last function:

``` ts
public static getKing(isWhite: boolean, board: Piece[][]): Piece {
    let kingColor: number = isWhite ? 6 : -6;
    for (let array of board)
        for (let piece of array)
            if (piece.value === kingColor)
                return piece;
    throw new Error("King not found");
}
```

So first we get which king to look for using a `ternary operator`.
The first line is equivalent to this:

``` ts
let kingColor: number;
if (isWhite)
    kingColor = 6;
else
    kingColor = -6;
```

Next we loop over all squares of the board and find the king.
If the king is not found, we throw an error.

### The Board file

First thing we do is initialize two multi-dimensional arrays:

``` ts
public static pieces: Piece[][] = [];
public static previousBoard: Piece[][];
```

You can think of a multi-dimensional array as an array full of other arrays:
Here is an example:

``` ts
let grid: number[][];
// When fully initialized as a 3*3 grid, it will look like this:

// [
//   [1, 2, 3],
//   [4, 5, 6],
//   [7, 8, 9]
// ]
```

Then we have a `constructor` that initializes the starting board with the starting FEN string.

Next we have these two functions:

``` ts
public drawNumbers(i: number, sideNumber: number): void {
    Functions.drawText(
        sideNumber.toString(), 
        DevSettings.numberLetterDimensions / 2, 
        (DevSettings.numberLetterDimensions * (i + 2)) - DevSettings.numberLetterDimensions / 2, 
        "black",
        "Arial", 
        20, 
        "middle", 
        "center",
        World.context
    );
}

public drawLetters(j: number) {
    Functions.drawText(
        String.fromCharCode(j + 'A'.charCodeAt(0)).toLowerCase(),
        (DevSettings.numberLetterDimensions * (j + 2)) - DevSettings.numberLetterDimensions / 2,
        DevSettings.numberLetterDimensions / 2, 
        "black",
        "Arial", 
        20, 
        "middle", 
        "center",
        World.context
    );
}
```

These are used to draw the letters and numbers on the side of the board.

Next we have the function to draw the board:

``` ts
public drawBoard(): void {
    let sideNumber: number = 8;
    for (let file = 0; file < 8; file++) {
        this.drawNumbers(file, sideNumber);
        for (let rank = 0; rank < 8; rank++) {
            this.drawLetters(rank);
            const isLightSquare: boolean = (file + rank) % 2 != 0;
            const squareColor: string = isLightSquare ? UserSettings.whiteSquareColor : UserSettings.blackSquareColor;
            const xOffset: number = DevSettings.numberLetterDimensions + (file * DevSettings.boxDimensions);
            const yOffset: number = DevSettings.numberLetterDimensions + (rank * DevSettings.boxDimensions);
            Functions.drawRect(squareColor, xOffset, yOffset, DevSettings.boxDimensions, DevSettings.boxDimensions);
        }
        sideNumber--;
    }
    const xyPosition = DevSettings.numberLetterDimensions;
    const widthHeight = DevSettings.boxDimensions * 8;
    Functions.drawStrokeRect("black", xyPosition, xyPosition, widthHeight, widthHeight);
}
```

Here we loop over each `file` and `rank` then check if the square is white or not.
The `const` keyword is like the `readonly` keyword.
The `%` (mod) operator is used to find the remainder of a division problem.
Then we get the square color with a `ternary`.
After that we calculate the `x` and `y` positions, then draw a rectangle.
After both loops we draw a rectangle, but with only the border.

Next we have a function that draws the pieces:

``` ts
public drawPieces(): void {
    for (let file = 0; file < 8; file++) {
        for (let rank = 0; rank < 8; rank++) {
            const piece: Piece = Board.pieces[rank][file];
            if (piece.value !== 0)
                Functions.drawImage(
                    Piece.getImageUrlFromFEN(piece.value), 
                    (piece.x * (DevSettings.numberLetterDimensions + 1)) + DevSettings.numberLetterDimensions + piece.dx,
                    (piece.y * (DevSettings.numberLetterDimensions + 1)) + DevSettings.numberLetterDimensions + piece.dy,
                    DevSettings.pieceDimensions, 
                    DevSettings.pieceDimensions
                );
        }
    }
}
```

This is almost the same as the `drawBoard` function but we are drawing pieces instead.
We'll go over the `Functions.drawImage` function later as it is very complicated.

### The Check File

First of we have a function that checks if a certain square is being attacked by a black piece:

``` ts
public static squareBeingAttackedByBlackPiece(squareX: number, squareY: number, board: Piece[][]): boolean {
    for (const array of board)
        for (const piece of array)
            if (piece.value < 0)
                switch (piece.value) {
                    case -1:
                        return Move.validBlackPawnCapture(piece, squareX, squareY);
                    case -2:
                        return Move.validKnightMove(piece, squareX, squareY);
                    case -3:
                        return Move.validBishopMove(piece, squareX, squareY);
                    case -4:
                        return Move.validRookMove(piece, squareX, squareY);
                    case -5:
                        return Move.validQueenMove(piece, squareX, squareY);
                    case -6:
                        return Move.validBlackKingMove(piece, squareX, squareY);
                }
    return false
}
```

What we do here is loop over every square on the board.
If that square has a black piece on it then we check if that piece can legally move to the square provided.

We have another function that does this for white pieces, but it is the inverse of the previous function, so I won't go over it.

Next we have a function that checks if the white king is in checkmate:

``` ts
public static whiteKingInCheckMate(): boolean {
    const king: Piece = Piece.getKing(true, Board.pieces);
    if (!Check.squareBeingAttackedByBlackPiece(king.x, king.y, Board.pieces))
        return false;
    for (const array of Board.pieces) {
        for (const piece of array) {
            if (piece.value > 0) {
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        if (Piece.getValidMove(piece, j, i) && (Board.pieces[j][i].value <= 0)) {
                            const pieceCopy: Piece = Functions.deepCopy(piece);
                            const newBoard: Piece[][] = Functions.deepCopy(Board.pieces);
                            newBoard[j][i] = pieceCopy;
                            newBoard[pieceCopy.y][pieceCopy.x] = new Piece(0, pieceCopy.x, pieceCopy.y);
                            pieceCopy.y = j;
                            pieceCopy.x = i;
                            const newKing: Piece = Piece.getKing(true, newBoard);
                            if (!Check.squareBeingAttackedByBlackPiece(newKing.x, newKing.y, newBoard))
                                return false
                        }
                    }
                }
            }
        }
    }
    return true;
}
```

First we get the white king and assign it to a variable.

Then we check if the king is check.
If he isn't, the we return `false`.
Then we loop over all the squares.
If we find a white piece, then we loop over all the squares again.
If we can legally move to that square, then we create a deep copy of the board and move there.
If the king is no longer in check, we return `false`.
If all the white pieces can't do anything, we return `true`.

The same function is used for `blackKingInCheckMate` but inverted.

### The Black File

First off, we have these two functions:

``` ts
public static getNumberOfBlackPieces(): number {
    let total: number = 0;
    for (let array of Board.pieces)
        for (let piece of array)
            if (piece !== null)
                if (piece.value < 0)
                    total++;
    return total;
}

public static getPromotion(piece: Piece, newY: number) {
    if (newY === 7 && piece.value === -1) {
        piece.value = 5;
    }
}
```

The first function simply returns the total number of black pieces.
The second function promotes a pawn to a queen.

Those two functions are quite simple, but now we get to the main function:

``` ts
public static makeMove(): void {
    const blackPieces: number = Black.getNumberOfBlackPieces();
    outer:
    while (true) {
        const pieceToPick: number = Functions.randomInteger(0, blackPieces - 1);
        let index: number = 0;
        let piecePick: Piece = new Piece(0, 0, 0);
        fast:
        for (const array of Board.pieces) {
            for (const piece of array) {
                if (index === pieceToPick) {
                    piecePick = piece;
                    break fast;
                }
                index++;
            }
        }
        let xOffset: number;
        let yOffset: number;
        let counter: number = 0;
        let king: Piece = Piece.getKing(false, Board.pieces);
        while (true) {
            if (Check.squareBeingAttackedByWhitePiece(king.x, king.y, Board.pieces)) {
                for (const array of Board.pieces) {
                    for (const piece of array) {
                        if (piece.value < 0) {
                            for (let i = 0; i < 8; i++) {
                                for (let j = 0; j < 8; j++) {
                                    if (Piece.getValidMove(piece, i, j) && (Board.pieces[j][i].value >= 0)) {
                                        const pieceCopy: Piece = Functions.deepCopy(piece);
                                        const newBoard: Piece[][] = Functions.deepCopy(Board.pieces);
                                        newBoard[j][i] = pieceCopy;
                                        newBoard[pieceCopy.y][pieceCopy.x] = new Piece(0, pieceCopy.x, pieceCopy.y);
                                        pieceCopy.y = j;
                                        pieceCopy.x = i;
                                        const newKing: Piece = Piece.getKing(false, newBoard);
                                        if (piece.value === -6) {
                                            newKing.y = j;
                                            newKing.x = i;
                                        }
                                        if (!Check.squareBeingAttackedByWhitePiece(newKing.x, newKing.y, newBoard)) {
                                            Board.pieces[j][i] = piece;
                                            Board.pieces[piece.y][piece.x] = new Piece(0, piece.x, piece.y);
                                            piece.x = i;
                                            piece.y = j;
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            counter++;
            if (counter == 10)
                continue outer;
            xOffset = Functions.randomInteger(0, 8) - 4;
            yOffset = Functions.randomInteger(0, 8) - 4;
            if (piecePick.x + xOffset < 0 || piecePick.x + xOffset > 7 || piecePick.y + yOffset < 0 || piecePick.y + yOffset > 7)
                continue;
            if (Board.pieces[piecePick.y + yOffset][piecePick.x + xOffset].value < 0)
                continue;
            if (Piece.getValidMove(piecePick, piecePick.x + xOffset, piecePick.y + yOffset))
                break;
        }
        let newBoard: Piece[][] = Functions.deepCopy(Board.pieces);
        king = Functions.deepCopy(Piece.getKing(false, newBoard));
        king.x += xOffset;
        king.y += yOffset;
        if (Check.squareBeingAttackedByWhitePiece(king.x, king.y, newBoard)) 
            continue;
        Board.pieces[piecePick.y + yOffset][piecePick.x + xOffset] = piecePick;
        Board.pieces[piecePick.y][piecePick.x] = new Piece(0, piecePick.x, piecePick.y);
        piecePick.x += xOffset;
        piecePick.y += yOffset;
        return;
    }
}
```

This long function is used to move a "random" piece.
So first we get the number of black pieces.
Then we make a `while` loop with a label of `outer`.
We'll go over labels later.
First we choose a random number between 0 and the number of black pieces minus one.
We do that by calling this function:

``` ts
public static randomInteger(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
```

I this function has a few built in `Math` functions:

- `Math.floor()`
  - Floor the value (1.55 to 1, 2.35435435 to 2)
- `Math.random()`
  - Return a "random" number between 0 and 1.

We then do a complicated formula to get a value between two numbers.
But that should be impossible.
Think about it.
Can computers generate random numbers?
They really can't.
Whenever you ask Siri "Generate a random number between 0 and 50, she isn't giving you a *random* number, but rather a *pseudo-random* number.
Pseudo-random numbers are generated using very complex formulas.
Here is a simple example.

In JavaScript, there is a function called `Date.now()` which returns a very large number.
Right now it should be around this number: `1662857532730`.
The is the amount of milliseconds that have elapsed since `January 1, 1970, 00:00:00`.
This number is what your computer uses to calculate the current date.
Now, this number is always changing.
Every second it goes up by 1000.
We can use this function in a formula to generate a "random" number.
Another aspect of pseudo-random number generation is a seed (Like a world seed in Minecraft).
Whenever you call `Math.random()`, you get a seed, and that seed is also used in the formula.
[This](https://healeycodes.com/creating-randomness) article is a good read on this.

From that website there is this function:

``` js
Math.random = (function () {
  var seed = 49734321
  return function () {
    // Robert Jenkins' 32 bit integer hash function.
    seed = seed & 0xffffffff
    seed = (seed + 0x7ed55d16 + (seed << 12)) & 0xffffffff
    seed = (seed ^ 0xc761c23c ^ (seed >>> 19)) & 0xffffffff
    seed = (seed + 0x165667b1 + (seed << 5)) & 0xffffffff
    seed = ((seed + 0xd3a2646c) ^ (seed << 9)) & 0xffffffff
    seed = (seed + 0xfd7046c5 + (seed << 3)) & 0xffffffff
    seed = (seed ^ 0xb55a4f09 ^ (seed >>> 16)) & 0xffffffff
    return (seed & 0xfffffff) / 0x10000000
  }
})()
```

This has a seed and uses `bitwise operator`s to calculate a "random" number.

Now if you've ever heard of binary (1's and 0's), it has to do with that.
Each number can be represented as a binary expression.
Here is 5 in binary: `00000101`
From each number starting at the right you double the previous number:

``` text
00000000
^^^^^^^^
|||||||1
||||||2
|||||4
||||8
|||16
||32
|64
128
```

So when you have `5 & 3`:

```text
00000101  5
00000011  3
```

Here is the truth table for `&`:

| a | b | a & b |
|---|---|-------|
| 0 | 0 | 0     |
| 0 | 1 | 0     |
| 1 | 0 | 0     |
| 1 | 1 | 1     |

So this is the output:

``` text
00000101  5 &
00000011  3
00000001
```

So this returns one.

After this, we choose a piece.
The `break fast` breaks out of the loop with a `label` called `fast`.
Then we initialize a counter and king.
First off, we check if the black king is check.
Then we activate a sort of "danger" mode, where black will loop over all the pieces.
As soon as he finds a valid move to get his king out of check, he will make it.
If the king is not check, then we add one to the counter.
Then if the counter is 10, we reset the program.
This is so that if a piece cannot move anywhere it will not stay on that piece forever.
Then we pick a random value between -4 and 4 twice.
That number will be added on to the piece's `x` and `y` to move it.
First, we check if the pieces `x` plus the random value (or `y`) is off the board.
If it is, we use the `continue` keyword to continue from the start of the `while` loop.
Then if the piece will move onto another black piece, we `continue`.
Then, if the piece is making a valid move, we `break` out of the loop.
After we are out of the loop, if we moved the king, we copy the king and see if it moved to a square that is being attacked.
If so we `return`.
Then we update the board and the `piecePick`s `x` and `y` accordingly.

> *a += 1 is essentialy a = a + 1.*

Ok, two more files.

### The Key Events file

Here is the `keyEvents.ts` file:

``` ts
class KeyEvents {
    public static lastY: number = 0;
    public static lastX: number = 0;

    public static selectedPiece: Piece | null;

    public static mouseIsDown: boolean = false;

    public static mouseDown(e: MouseEvent): void {
        e.preventDefault();
        e.stopPropagation();
        this.lastX = Functions.getMousePos(e).x;
        this.lastY = Functions.getMousePos(e).y;
        const mouseX: number = Math.floor(Functions.getMousePos(e).x / DevSettings.boxDimensions) - 1;
        const mouseY: number = Math.floor(Functions.getMousePos(e).y / DevSettings.boxDimensions) - 1;
        dance:
        for (let file = 0; file < 8; file++)
            for (let rank = 0; rank < 8; rank++)
                if (file == mouseX && rank == mouseY) {
                    if (Board.pieces[rank][file].value > 0)
                        this.selectedPiece = Board.pieces[rank][file]!;
                    break dance;
                }
        this.selectedPiece!.selected = true;
        World.dragging = true;
        this.mouseIsDown = true;
    }

    public static mouseUp(e: MouseEvent): void {
        if (!World.dragging)
            return;
        e.preventDefault();
        World.dragging = false;
        this.selectedPiece!.move(e);
        this.selectedPiece = null;
    }

    public static mouseMove(e: MouseEvent): void {
        if (!World.dragging)
            return;
        e.preventDefault();
        const mouseX: number = Functions.getMousePos(e).x;
        const mouseY: number = Functions.getMousePos(e).y;

        this.selectedPiece!.dx = mouseX - this.lastX;
        this.selectedPiece!.dy = mouseY - this.lastY;
    }
}
```

First we make a bunch of variables.

Next we have a function that occurs when we click the mouse.

First we use `preventDefault` and `stopPropagation` to tell the browser that we will be handling the event.
Next we get the current mouse position and map them to `lastX` and `lastY`.
After that we have two constants that get the squares that the mouse is currently over.
Next we loop over all the squares in the board and get the piece that the user is over.
Then we set three variables to `true`.

After that we deal with when the mouse goes up.
If we are not currently dragging the mouse, then we `return`.
If so we set `dragging` to `false` and move the selected piece.
Then we set the selected piece to `null`.

Finally, we deal with when the mouse moves.
First off, if the mouse is not `dragging`, then we `return`.
Next we get the current `mouseX` and `mouseY` values.
Finally we set the `dx` and `dy` values.
`dx` and `dy` are used to display the piece actually moving.

### The initialization file

The final file.
This one will take a while.

First off we make a `new World()`:

``` ts
const world: World = new World();
```

Simple.

Now we have this function:

``` ts
async function main(): Promise<void> {
    await Functions.loadImages();
    world.board.drawBoard();
}
```

This is an `async` function.

Now, JavaScript has this weird thing that, if a process is taking too long, then it will skip that process and move on.
When it feels like it, it will go back and finish up that process.
What we need to do before the game loads is to load in the images.
A normal image load in would look like this:

``` js
const image = new Image();
image.src = "image_url.png";
image.onload = () => {
    context.drawImage(x, y, width, height);
};
```

First we create the image, then assign it an `src`.
After that, we wait for the image to load, and then we draw it.

But if we did this in a function, even after the image is loaded, it will be loaded in over and over again because we create an image will each call.

So, this is where we have this function:

``` ts
public static async loadImages(): Promise<void> {
    const imageLinks: string[] = [
        "images/Basic/BlackBishop.png",
        "images/Basic/BlackKing.png",
        "images/Basic/BlackKnight.png",
        "images/Basic/BlackPawn.png",
        "images/Basic/BlackQueen.png",
        "images/Basic/BlackRook.png",
        "images/Basic/WhiteBishop.png",
        "images/Basic/WhiteKing.png",
        "images/Basic/WhiteKnight.png",
        "images/Basic/WhitePawn.png",
        "images/Basic/WhiteQueen.png",
        "images/Basic/WhiteRook.png",
    ];

    let loadImage = async (link: string) => {
        const image: HTMLImageElement = new Image();
        image.src = link;

        
        return new Promise((resolve) => {
            image.onload = async () => {
                Functions.images.set(link, image);
                resolve(true);
            };
        });
    };
    
    for (let i = 0; i < imageLinks.length; i++) {
        await loadImage(imageLinks[i]);
    }
}
```

First we create an array of all the images we need to load in.
Then we create a function (within a function) that loads in a single image.
We first create the image and then give it an `src`.
After that we return a new `Promise`.
A `Promise` is an object that eventually will be resolved.
We first load in the image.
After we do that, we call the `set` method on a dictionary that we defined at the top:

```ts
public static images: Map<string, HTMLImageElement> = new Map<string, HTMLImageElement>();
```

`set()` creates a new object in the dictionary.
The first argument will be the `key`, and the second one will be the `value`.
So we set the link of the image to the image.
Then we call `resolve(true)` to signify that the `Promise()` has been fulfilled.
Then we look over all the images and `await` a load in.
`await` is used within an `async` function to stop all other processes and focus on whatever you are `await`ing.
Then, we have our `drawImage()` function:

``` ts
public static drawImage(src: string, x: number, y: number, width: number = 50, height: number = 50) {
    const image: HTMLImageElement = Functions.images.get(src)!;
    World.context.drawImage(image, x, y, width, height);
}
```

Now all we have to do is get the image from the `src`, and use the context to draw the image.
We don't need to worry about the image not being loaded in because we dealt with that in our `init.ts` file.

Now back to our `main()` function, we `await` the function that loads in all the images.
Then we draw the board.

Then we call that function.

After that, we have a `run()` function:

``` ts
function run() {
    world.board.drawBoard();
    world.board.drawPieces();
    World.history.context.clearRect(0, 0, World.history.canvas.width, World.history.canvas.height);
    World.history.print();
}
```

This first draw's the board, then the pieces, and then clears the history canvas and draws all the history components.

Then we finally reach our last line of code:

``` ts
setInterval(run, 33);
```

This function will call the `run()` function every 33 milliseconds.
We don't need the parenthesis in this case because we only need to reference it.

And thats it!
Thanks for reading all the way to the end.
See you next time.

---
